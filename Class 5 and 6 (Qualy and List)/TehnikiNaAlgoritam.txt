1. Груба Сила (Brute Force)
Објаснување:
Груба сила е едноставен и директен пристап за решавање на проблеми каде што ги испробуваме сите можни решенија и го избираме најдоброто. Ова е најефективниот начин за мали проблеми, 
но може да биде многу неефикасен за поголеми проблеми поради големиот број на можни решенија кои треба да се разгледаат.

Пример:
Најди го максималниот број во листа.

java
Copy code
public class BruteForceExample {
    public static int findMax(int[] array) {
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
        }
        return max;
    }

    public static void main(String[] args) {
        int[] array = {1, 5, 3, 9, 2};
        System.out.println("The maximum value is: " + findMax(array));
    }
}


2. Алчен Алгоритам (Greedy)
Објаснување:
Алчен алгоритам е метод кој во секој чекор го избира најдоброто локално решение, со надеж дека ќе дојде до глобално оптимално решение. 
Овие алгоритми не секогаш даваат оптимално решение за сите проблеми, 
но се многу ефикасни за одредени видови проблеми.

Пример:
Алчен алгоритам за проблемот со кусури. Да се најде минимален број на монети потребни за да се направи дадената сума.

java
Copy code
import java.util.Arrays;

public class GreedyExample {
    public static int minCoins(int[] coins, int amount) {
        Arrays.sort(coins);
        int count = 0;
        for (int i = coins.length - 1; i >= 0; i--) {
            while (amount > coins[i]) {
                amount -= coins[i];
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        int[] coins = {1, 2, 5, 10, 20, 50};
        int amount = 63;
        System.out.println("Minimum coins required: " + minCoins(coins, amount));
    }
}


Што е Динамичко Програмирање?
Динамичко Програмирање (DP) е техника за решавање на сложени проблеми со разложување на проблемот на помали, преклопувачки подпроблеми. 
Основната идеја е да се избегне решавање на истите подпроблеми повеќе пати со зачувување на нивните решенија (меморизација) 
и користење на тие зачувани решенија при решавање на поголемите проблеми.

public class DynamicProgrammingExample {
    public static int fibonacci(int n) {
        if (n <= 1) { // Базни случаи
            return n;
        }
        int[] fib = new int[n + 1]; // Низа за складирање на Фибоначиеви броеви
        fib[0] = 0; // Фибоначијев број за 0
        fib[1] = 1; // Фибоначијев број за 1
        for (int i = 2; i <= n; i++) { // Ги пополнуваме останатите броеви
            fib[i] = fib[i - 1] + fib[i - 2]; // Секој број е збир од претходните два
        }
        return fib[n]; // Го враќаме n-тиот Фибоначијев број
    }

    public static void main(String[] args) {
        int n = 10; // Пример вредност
        System.out.println("Fibonacci number at position " + n + " is: " + fibonacci(n)); // Очекуван излез: 55
    }
}

Зошто се користи Динамичко Програмирање?
Ефикасност: DP значително ја намалува времето на извршување за проблеми со многу преклопувачки подпроблеми.
Оптимизација: DP овозможува наоѓање на оптимално решение за проблеми кои имаат оптимална подструктура 
(на пример, најкраток пат, максимална вредност, минимален трошок).
Мемоизација: Со зачувување на резултатите од подпроблемите, DP избегнува повторување на пресметките, што го прави многу поефикасно.
Каде се користи Динамичко Програмирање?
Фибоначиеви броеви:

Проблем: Пресметај го n-тиот Фибоначијев број.
Зошто DP: Избегнува повторно пресметување на исти броеви преку зачувување на претходно пресметаните резултати.
Проблем на најдолг заеднички подниз (Longest Common Subsequence - LCS):

Проблем: Најди ја најдолгата подниза која е заедничка за две низа.
Зошто DP: Мемоизацијата овозможува ефикасно решавање на преклопувачките подпроблеми за секоја подниза.
Проблем со кнапсак (Knapsack problem):

Проблем: Дадени се тежини и вредности на предмети, најди максимална вредност што може да се добие со ограничена тежина на ранец.
Зошто DP: Зачувувањето на решенијата на подпроблемите овозможува оптимално решение за максималната вредност.
Патување продавач (Traveling Salesman Problem - TSP):

Проблем: Најди ја најкратката патека која ги посетува сите градови и се враќа на почетната точка.
Зошто DP: DP го намалува бројот на можни патеки преку меморизација на подпроблемите за патувања меѓу градовите.
